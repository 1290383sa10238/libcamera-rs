use indoc::printdoc;
use libcamera_meta::{control_ids, property_ids, Control, ControlType};

fn format_docstring(desc: &str, indent: usize) -> String {
    desc.trim()
        .split("\n")
        .map(|line| format!("{}/// {}\n", " ".repeat(indent), line))
        .collect::<String>()
}

fn to_rust_type(t: ControlType) -> &'static str {
    match t {
        ControlType::Bool => "bool",
        ControlType::Byte => "u8",
        ControlType::Int32 => "i32",
        ControlType::Int64 => "i64",
        ControlType::Float => "f32",
        ControlType::String => "String",
        ControlType::Rectangle => "Rectangle",
        ControlType::Size => "Size",
    }
}

fn generate_controls(controls: &Vec<Control>, name: &str) {
    let mut i = 1;
    println!("#[derive(Debug, Clone, Copy, Eq, PartialEq, TryFromPrimitive, IntoPrimitive)]");
    println!("#[repr(u32)]");
    println!("pub enum {} {{", name);
    for ctrl in controls.iter() {
        print!("{}", format_docstring(&ctrl.description, 4));
        println!("    {} = {},", &ctrl.name, i);
        i += 1;
    }
    println!("}}\n");

    let mut dyn_variants = String::new();

    for ctrl in controls.iter() {
        let ctrl_name = &ctrl.name;
        let ctrl_type = to_rust_type(ctrl.typ);

        print!("{}", format_docstring(&ctrl.description, 0));
        if let Some(enumeration) = &ctrl.enumeration {
            println!("#[derive(Debug, Clone, Copy, Eq, PartialEq, TryFromPrimitive, IntoPrimitive)]");
            println!("#[repr({})]", ctrl_type);
            println!("pub enum {ctrl_name} {{");
            for val in enumeration {
                let var_name = val.name.replace(&ctrl.name, "");

                print!("{}", format_docstring(&val.description, 4));
                println!("    {var_name} = {},", val.value);
            }
            println!("}}\n");

            printdoc! {"
                impl TryFrom<ControlValue> for {ctrl_name} {{
                    type Error = ControlValueError;
                
                    fn try_from(value: ControlValue) -> Result<Self, Self::Error> {{
                        Self::try_from({ctrl_type}::try_from(value.clone())?).map_err(|_| ControlValueError::UnknownVariant(value))
                    }}
                }}
                
                impl From<{ctrl_name}> for ControlValue {{
                    fn from(val: {ctrl_name}) -> Self {{
                        ControlValue::from({ctrl_type}::from(val))
                    }}
                }}

                impl Control for {ctrl_name} {{
                    const ID: u32 = {name}::{ctrl_name} as _;
                }}\n
            "};
        } else {
            printdoc! {"
                #[derive(Debug, Clone)]
                pub struct {ctrl_name}(pub {ctrl_type});

                impl Deref for {ctrl_name} {{
                    type Target = {ctrl_type};
                
                    fn deref(&self) -> &Self::Target {{
                        &self.0
                    }}
                }}
                
                impl DerefMut for {ctrl_name} {{
                    fn deref_mut(&mut self) -> &mut Self::Target {{
                        &mut self.0
                    }}
                }}

                impl TryFrom<ControlValue> for {ctrl_name} {{
                    type Error = ControlValueError;

                    fn try_from(value: ControlValue) -> Result<Self, Self::Error> {{
                        Ok(Self({ctrl_type}::try_from(value)?))
                    }}
                }}

                impl From<{ctrl_name}> for ControlValue {{
                    fn from(val: {ctrl_name}) -> Self {{
                        ControlValue::from(val.0)
                    }}
                }}

                impl Control for {ctrl_name} {{
                    const ID: u32 = {name}::{ctrl_name} as _;
                }}\n
            "};
        }

        dyn_variants.push_str(&format!(
            "{name}::{ctrl_name} => Ok(Box::new({ctrl_name}::try_from(val)?)),\n"
        ));
    }

    printdoc! {"
        pub fn make_dyn(id: {name}, val: ControlValue) -> Result<Box<dyn DynControl>, ControlValueError> {{
            match id {{
                {dyn_variants}
            }}
        }}
    "};
}

fn main() {
    let args = std::env::args().collect::<Vec<_>>();
    match args.get(1).map(String::as_str) {
        Some("controls") => {
            println!("//! Generated by `cargo run --bin generate_rust controls`\n");
            println!("use std::ops::{{Deref, DerefMut}};");
            println!("use num_enum::{{IntoPrimitive, TryFromPrimitive}};");
            println!("use crate::control::{{Control, DynControl}};");
            println!("use crate::control_value::{{ControlValue, ControlValueError}};");
            println!("#[allow(unused_imports)]");
            println!("use crate::geometry::{{Rectangle, Size}};\n");
            let controls = control_ids();
            generate_controls(&controls, "ControlId");
        }
        Some("properties") => {
            println!("//! Generated by `cargo run --bin generate_rust properties`\n");
            println!("use std::ops::{{Deref, DerefMut}};");
            println!("use num_enum::{{IntoPrimitive, TryFromPrimitive}};");
            println!("use crate::control::{{Control, DynControl}};");
            println!("use crate::control_value::{{ControlValue, ControlValueError}};");
            println!("#[allow(unused_imports)]");
            println!("use crate::geometry::{{Rectangle, Size}};\n");
            let properties = property_ids();
            generate_controls(&properties, "PropertyId");
        }
        _ => {
            eprintln!("Usage: generate_rust [controls|properties]")
        }
    }
}
